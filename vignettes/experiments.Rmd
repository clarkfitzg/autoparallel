---
title: "autoparallel-experiments"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{autoparallel-interactive}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Experiments

Motivation for the tools inside `autoparallel`.

## 1 Fast Functions

If the function that `lapply()` calls is fast, then I expect a direct
translation to `mclapply()` will be slower. I expect that one can improve
the speed by splitting the lapply call into the number of chunks to match
the number of workers and then calling something like `mclapply(lapply(...))`.
This is how the `apply` transformation works.

Is this always the case? Not if one block of code takes much longer- then
there's a load balancing issue and the load balancing tools in the parallel
package should probably be used. Random selection of pieces to execute may
help in this regard.

```{R}

library(microbenchmark)

x = seq(1e6)

bm1 = microbenchmark(lapply(x, function(xi) NULL), times = 10L)

# Lower quartile 463 ms
bm1

bm2 = microbenchmark(parallel::mclapply(x, function(xi) NULL, mc.cores = 2L), times = 10L)

# Lower quartile 499 ms
bm2

cl = parallel::makeCluster(2L)

bm3 = microbenchmark(parallel::parLapply(cl, x, function(xi) NULL), times = 10L)

# Lower quartile 552 ms
bm3

```

These times are similar. I just looked at the source of
`parallel::mclapply` and saw that it indeed already does this chunking for
efficiency that I had in mind here. And `parallel::parLapply` even uses
`parallel::splitIndices`.

This implies that it's unnecessary to take any pains to chunk the
`apply` calls as I did previously. Instead I can simply feed them straight in
to the corresponding version in `parallel`.

## 2 Loop Reordering

What are necessary and sufficient conditions to be able to run lapply calls
in parallel? Can we detect programmatically if they are satisfied?

The `lapply` calls a function rather than a statement. Most functions called
with `lapply` are probably pure, meaning they have no side effects. This is
a sufficient condition to say we can fully reorder statements. But it's
stronger than we need.


## 3 Data Motion

Can we look at the code and prevent data motion? For example:


```{R}

x = as.list(1:10)
y = lapply(x, function(xi) 2 * xi)
sy = Reduce(`+`, y)                 # Push partially to worker
z = lapply(y, function(yi) yi - 3)  # Never bring to manager
sz = Reduce(`+`, z)                 # Push to worker

```

Assume the `Reduce` function is associative and these data sizes are
prohibitively large for moving. Then it would be a win here to split the
`lapply` calls as above and push the `Reduce` into the workers. `z` also
never needs to come back to the manager.

Related question, how large is too large?
