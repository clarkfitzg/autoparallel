---
title: "for loops"
author: "Clark Fitzgerald"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

I'm considering the task of how to generally recognize parallelism in an R
for loop.

Here's the most basic thing I'd like to do:


```{R}
for(i in seq_along(x)) {
    ans[i] = f(x[i])
}
```


# Data dependency

## RAW Read After Write

Here's an example of one with true dependence, ie. not parallelizable:

```{R}

estimate = 10
for(i in 1:n) {
   estimate = update(estimate)
}

```

Basic heuristic: If the LHS of the assignment, say `ans[i]`, is never used
on the RHS, then we should be able to parallelize the loop. Probably most
cases where we can make it parallel are when the code uses an index from
the loop.


## Harder example:

```{R}
# loop version, uses symmetry and builtin covariance
cov_loop2 = function(x)
{
    p = ncol(x)

    output = matrix(numeric(p*p), nrow = p)
    for(i in 1:p){
        for(j in i:p){
            covij = cov(x[, i], x[, j])
            output[i, j] = covij
            output[j, i] = covij
        }
    }
    output
}

```

Suppose we split up the for loop. How would I actually implement this in
parallel? I'd have to determine that they don't write over each other and
merge the results. This will be painful.

