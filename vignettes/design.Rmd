## multiple calls

Initially I'm thinking to find and transform the first instance of `lapply`
family functions that is discovered in each statement. This should help
avoid nested parallelism. But consider this single statement:

```{R}
f(lapply(x, gx), lapply(y, gy))
```

Suppose the most efficient code is:

```{R}
f(lapply(x, gx), mclapply(y, gy))
```

Then with the current design we cannot discover this. One way around might
be to rewrite the original code as:

```{R}
f_arg1 = lapply(x, gx)
f_arg2 = lapply(y, gy)
f(f_arg1, f_arg2)
rm(f_arg1)
rm(f_arg2)
```

This effectively removes one layer of nested function calls, allowing us to
examine all arguments. Does anything stop us from doing this recursively?
Of course it's possible to go too far with this idea, inlining code and
recursing into the bodies of built in functions. Modifying built in
functions seems excessively complicated and error prone.

One issue with this approach is that argument evaluation is forced rather
than lazy.


## code not executed

Note: this all seems like a second order consideration. 
Suppose the user writes:

```{R}
f = function(x) lapply(x, g)

f(y)
f(z)
```

It may be the case that the fastest way to run `f(y)` is by changing `lapply`
to `mclapply`, while the fastest way to run `f(z)` is to just keep the
`lapply`.

There's no point in benchmarking `function(x) lapply(x, g)`, because the
`lapply` does not run there. We could statically analyze the code to see if
it runs, or we could actually run it and do something like `trace(lapply)`.

We could work around it
by inlining user defined functions. One obvious issue there is clobbering
global variables, ie:

```{R}

f = function(x){
    z = 10
    x + z
}
z = 20
f(5)

```

If we just inline the code it becomes:

```{R}

z = 20
z = 10
x = 5
x + z

```

So we need to do something more clever, ie. create a new frame for
evaluation. By the time we do that we're on our way to recreating functions
:) Then maybe it makes more sense to just handle functions as a special
case.


## evaluation

Definitely need to be more careful about when and how the expressions are
evaluated when benchmarking the script. One way might be to evaluate
everything in a specially created
environment inheriting from the global environment.

We could also look at the code more closely to determine if it's acceptable
to evaluate it many times for a benchmark. For example, the following is
not:

```{R}

x = lapply(x, f)

```

This could be handled by SSA.


## parse tree

Thinking about the difference between parse trees and abstract syntax trees
(AST). One advantage to sticking with the parse tree is that we don't
unnecessarily change code when writing a transformed version back out to a file.
