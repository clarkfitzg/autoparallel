% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scheduleVector.R
\name{scheduleVector}
\alias{scheduleVector}
\title{Schedule Based On Vectorized Blocks}
\usage{
scheduleVector(graph, platform = Platform(), data = list(),
  save_var = character(), nWorkers = platform@nWorkers,
  known_vector_funcs = c("exp", "+", "*"), vector_funcs = character(),
  all_vector_funcs = c(known_vector_funcs, vector_funcs))
}
\arguments{
\item{graph}{\linkS4class{TaskGraph}, code dependency graph}

\item{platform}{\linkS4class{Platform} describing resource to compute on}

\item{data}{list of data descriptions. 
Each element is a \linkS4class{DataSource}.
The names of the list elements correspond to the variables in the code that these objects are bound to.}

\item{save_var}{character, name of the variable to save}

\item{known_vector_funcs}{character, the names of vectorized functions from recommended and base packages.}

\item{vector_funcs}{character, names of additional vectorized functions known to the user.}

\item{all_vector_funcs}{character, names of all vectorized functions to use in the analysis.}
}
\description{
This scheduler combines as many vectorized expressions as it can into one large block of vectorized expressions to run in parallel.
The initial data chunks and intermediate objects stay on the workers and do not return to the manager, so you can think of it as "chunk fusion".
}
\details{
TODO:
\enumerate{
\item Populate \code{known_vector_funcs} based on code analysis.
\item Model non vectorized functions so that we can revisit the chunked data.
Currently it only allows for one chunked block.
\item Identify which parameters a function is vectorized in, and respect these by matching arguments.
See \code{update_resource.Call}.
\item Clarify behavior of subexpressions, handling cases such as \code{min(sin(large_object))}
}
}
\seealso{
\link{makeParallel}, \link{schedule}
}
