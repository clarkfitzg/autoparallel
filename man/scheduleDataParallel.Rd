% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scheduleDataParallel.R
\name{scheduleDataParallel}
\alias{scheduleDataParallel}
\title{Schedule Based On splittable Blocks}
\usage{
scheduleDataParallel(graph, platform = Platform(), data = list(),
  nWorkers = platform@nWorkers, KnownSplittableFuncs = c("exp", "+",
  "*", "sin"), splittableFuncs = character(),
  allSplittableFuncs = c(KnownSplittableFuncs, splittableFuncs))
}
\arguments{
\item{graph}{\linkS4class{TaskGraph}, code dependency graph}

\item{platform}{\linkS4class{Platform} describing resource to compute on}

\item{data}{list of data descriptions. 
Each element is a \linkS4class{DataSource}.
The names of the list elements correspond to the variables in the code that these objects are bound to.}

\item{splittableFuncs}{character, names of additional splittable functions known to the user.}

\item{allSplittableFuncs}{character, names of all splittable functions to use in the analysis.}

\item{knownSplittableFuncs}{character, the names of splittable functions from recommended and base packages.}
}
\description{
This scheduler combines as many splittable expressions as it can into one large block of splittable expressions to run in parallel.
The initial data chunks and intermediate objects stay on the workers and do not return to the manager, so you can think of it as "chunk fusion".
}
\details{
It balances the load of the data chunks among workers, assuming that loading and processing times are linear in the size of the data.

TODO:
\enumerate{
\item Populate \code{splittableFuncs} based on code analysis.
\item Model non splittable functions so that we can revisit the chunked data.
Currently it only allows for one chunked block.
\item Identify which parameters a function is splittable in, and respect these by matching arguments.
See \code{update_resource.Call}.
\item Clarify behavior of subexpressions, handling cases such as \code{min(sin(large_object))}
}
}
\seealso{
\link{makeParallel}, \link{schedule}
}
