% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scheduleDataParallel.R
\name{scheduleDataParallel}
\alias{scheduleDataParallel}
\title{Schedule Based On Data Parallelism}
\usage{
scheduleDataParallel(graph, platform = Platform(), data,
  nWorkers = platform@nWorkers, chunkFuncs = character(),
  reduceFuncs = list(), knownChunkFuncs = c("exp", "+", "*", "sin"),
  allChunkFuncs = c(knownChunkFuncs, chunkFuncs))
}
\arguments{
\item{graph}{\linkS4class{TaskGraph}, code dependency graph}

\item{platform}{\linkS4class{Platform} describing resource to compute on}

\item{data}{list of data descriptions. 
Each element is a \linkS4class{DataSource}.
The names of the list elements correspond to the variables in the code that these objects are bound to.}

\item{chunkFuncs}{character, names of additional chunkable functions known to the user.}

\item{reduceFuncs}{list of ReduceFun objects}

\item{knownchunkFuncs}{character, the names of chunkable functions from recommended and base packages.}

\item{allchunkFuncs}{character, names of all chunkable functions to use in the analysis.}
}
\description{
If you're doing a series of computations over a large data set, then start with this scheduler.
This scheduler combines as many chunkable expressions as it can into large blocks of chunkable expressions to run in parallel.
The initial data chunks and intermediate objects stay on the workers and do not return to the manager, so you can think of it as "chunk fusion".
}
\details{
It statically balances the load of the data chunks among workers, assuming that loading and processing times are linear in the size of the data.

TODO:
\enumerate{
\item Populate \code{chunkableFuncs} based on code analysis.
\item Identify which parameters a function is chunkable in, and respect these by matching arguments.
See \code{update_resource.Call}.
\item Clarify behavior of subexpressions, handling cases such as \code{min(sin(large_object))}
}
}
\seealso{
\link{makeParallel}, \link{schedule}
}
