To discuss for code review:

The current design "nests" the objects together, so Graph is a slot in Schedule
and Schedule is a slot in GeneratedCode. 

If I wanted "flatter" objects I could make each class inherit from
another. But this has disadvantages:

1. They're conceptually quite different objects
2. When I define a new class extending the first class (DependGraph)
   then how do I propagate the new slots through to the subclasses?
3. How can I easily call say the `plot()` method for the first class,
   if all the others have plot methods? I would actually like to do
   this.

If the nesting bothers me, I could define methods for the `[` so it goes
away.

Other considerations:

- Could rename package to parallelize. Then main end user function is
  parallelize::parallelize(). So users only have to remember one thing.
  Otherwise it could be autoParallel::autoParallel, but I don't want the
  package name to be CamelCase.
- Should I use an `eval()` generic? I currently have a function called
  `runMeasure` that measures how long every statement takes and the size of
  all the objects that could be transferred.
- What's the best way to keep the arguments to schedule() consistent? I could
  put them in the generic, but it's not clear that I want to dispatch on
  them. Right now they're in scheduleTaskList.

TODO list:

- Pass R CMD check
- Add error classes to messages
- Only write to tmp directories
- Drop all the functions and objects that I don't use
- All items in code marked `TODO:*`
- Make sure documentation can be accessed
- Revisit Apache hive code generation function
- Make sure object naming convention and argument names are consistent for
  all exported objects.
- Move some simple cases from tests to the function examples

Can defer:

- Global option for overwriting files

Done:

- Unit tests passing
- Run tests on generated code
- Switch to S4
- Read templates when necessary
- Return expression objects rather than text


Fri Jun  8 12:00:36 PDT 2018

Talking with Duncan has gotten me to think more deeply about what kind of
object oriented system I want to use. S3 is simpler while S4 is more
complex. But I don't understand either of them, because this passing
default arguments has got me confused. Do any R S3 methods use default
arguments?

Conceptually there are 3 important objects: TaskGraph, Schedule,
GeneratedCode

I would like to have these features right now:

- methods to create a TaskGraph from different inputs
- plot methods for TaskGraph
- Allow user to define their own code_generator function to dispatch on
  Schedule and return object of GeneratedCode
- The flexibility to add arbitrary elements to classes

In the future I might like to have these features:

- summary, print, and more plot methods
- ways to describe data and systems so that these feed into the scheduling
- object validation for Schedule objects, because one can
create schedules that aren't valid (which implies problems with the
schedule generator)


# TODO


Less urgent:

- Conversion to igraph objects
- preprocessing step
- Alternative scheduling algorithm and code generator based on fork / join.
- Measure CPU utilization during timings to see what's parallel / threaded.


## Done

- Show a realistic script as an example that actually benefits from task parallelism.
- Vignettes.
- Robust test for expression equality
- Write the `data_parallel()` function, including modification of for loops
  into parallel code.
- Handle assignment inside of a for loop of the form `x[[i]] = ...`
